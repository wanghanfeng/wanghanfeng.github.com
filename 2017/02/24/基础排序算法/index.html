<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>基础排序算法 | 王韩峰的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基础排序算法</h1><a id="logo" href="/.">王韩峰的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">基础排序算法</h1><div class="post-meta">Feb 24, 2017<span> | </span><span class="category"><a href="/categories/算法与数据结构/">算法与数据结构</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#各种排序算法的性能特点"><span class="toc-number">1.</span> <span class="toc-text">各种排序算法的性能特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度：一个算法消耗的时间与算法中语句的执行次数成正比例，语句执行次数多，它花费时间就多"><span class="toc-number">1.0.1.</span> <span class="toc-text">时间复杂度：一个算法消耗的时间与算法中语句的执行次数成正比例，语句执行次数多，它花费时间就多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空间复杂度：算法在计算机内执行时所需存储空间的度量"><span class="toc-number">1.0.2.</span> <span class="toc-text">空间复杂度：算法在计算机内执行时所需存储空间的度量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#稳定性：若待排序的数组中，存在多个相同的值，经过排序，这些值的相对次序保持不变，则称该算法是稳定的；若经排序后，相同值之间的相对次序发生了改变，则称该算法是不稳定的"><span class="toc-number">1.0.3.</span> <span class="toc-text">稳定性：若待排序的数组中，存在多个相同的值，经过排序，这些值的相对次序保持不变，则称该算法是稳定的；若经排序后，相同值之间的相对次序发生了改变，则称该算法是不稳定的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模版"><span class="toc-number">2.</span> <span class="toc-text">模版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序"><span class="toc-number">3.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序"><span class="toc-number">4.</span> <span class="toc-text">插入排序</span></a></li></ol></div></div><div class="post-content"><p>本文是对《算法 第四版》中排序章节的总结，包括 选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序</p>
<h2 id="各种排序算法的性能特点"><a href="#各种排序算法的性能特点" class="headerlink" title="各种排序算法的性能特点"></a>各种排序算法的性能特点</h2><p>有多种排序算法存在，就是因为各种算法拥有不同的性能特点，各有所长，适用于不同场合，下面是对各种排序算法的性能特点的总结：</p>
<h4 id="时间复杂度：一个算法消耗的时间与算法中语句的执行次数成正比例，语句执行次数多，它花费时间就多"><a href="#时间复杂度：一个算法消耗的时间与算法中语句的执行次数成正比例，语句执行次数多，它花费时间就多" class="headerlink" title="时间复杂度：一个算法消耗的时间与算法中语句的执行次数成正比例，语句执行次数多，它花费时间就多"></a>时间复杂度：一个算法消耗的时间与算法中语句的执行次数成正比例，语句执行次数多，它花费时间就多</h4><h4 id="空间复杂度：算法在计算机内执行时所需存储空间的度量"><a href="#空间复杂度：算法在计算机内执行时所需存储空间的度量" class="headerlink" title="空间复杂度：算法在计算机内执行时所需存储空间的度量"></a>空间复杂度：算法在计算机内执行时所需存储空间的度量</h4><h4 id="稳定性：若待排序的数组中，存在多个相同的值，经过排序，这些值的相对次序保持不变，则称该算法是稳定的；若经排序后，相同值之间的相对次序发生了改变，则称该算法是不稳定的"><a href="#稳定性：若待排序的数组中，存在多个相同的值，经过排序，这些值的相对次序保持不变，则称该算法是稳定的；若经排序后，相同值之间的相对次序发生了改变，则称该算法是不稳定的" class="headerlink" title="稳定性：若待排序的数组中，存在多个相同的值，经过排序，这些值的相对次序保持不变，则称该算法是稳定的；若经排序后，相同值之间的相对次序发生了改变，则称该算法是不稳定的"></a>稳定性：若待排序的数组中，存在多个相同的值，经过排序，这些值的相对次序保持不变，则称该算法是稳定的；若经排序后，相同值之间的相对次序发生了改变，则称该算法是不稳定的</h4><table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">最差: N^2，平均: N^2，最优: N^2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">最差: N^2，平均: N^2，最优: N</td>
<td style="text-align:center">1</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">最差: NlogN，平均: NlogN，最优: 与递增序列有关</td>
<td style="text-align:center">1</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">最差: NlogN，平均: NlogN，最优: NlogN</td>
<td style="text-align:center">N</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">最差: N^2，平均: NlogN，最优: NlogN</td>
<td style="text-align:center">lgN</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">最差: NlogN，平均: NlogN，最优: NlogN</td>
<td style="text-align:center">1</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<p>本文使用 Java 实现以上几种排序算法，并对《算法 第四版》书中的代码稍有修改，作为演示，只针对 int[] 类型进行排序，因此文中排序算法的输入源都是 int[] 类型，并且将一些公共方法抽离出来，比如比较两个数大小的 less() 和交换两个数的 exchange() 方法，公共方法放在抽象类 SortModel.java 中，其他具体的排序方法只需要继承它，并实现自己特有的 sort() 方法即可</p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>将排序算法的公共方法放在一个抽象类中，具体的排序算法类只需要继承自这个抽象类，并实现自己的 sort() 方法即可，具体代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">SortModel</span> &#123;</div><div class="line">	<span class="comment">//记录排序消耗的时间</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> usedTime = <span class="number">0</span>;</div><div class="line">	<span class="comment">//具体的排序方法,由子类实现</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="params"><span class="keyword">int</span>[] a</span>)</span>;</div><div class="line">    <span class="comment">//比较 a 和 b 的大小，如果 a 小于 b，则返回 true</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> boolean <span class="title">less</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> a &lt; b;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//交换数组中的两个数</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exchange</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b</span>) </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[a];</div><div class="line">        arr[a] = arr[b];</div><div class="line">        arr[b] = temp;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//打印数组</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> count</span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"\n\n使用 "</span> + getSortMethod() + <span class="string">" 对 "</span> + count + <span class="string">" 个数排序用时: "</span> + usedTime + <span class="string">"ms"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</div><div class="line">            System.<span class="keyword">out</span>.print(<span class="string">" "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取当前使用的排序方法名称</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getSortMethod</span>(<span class="params"></span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是比较基础的排序算法，具体描述是：<em>首先找到数组中最小的元素(这是一个遍历比较的过程)，然后将它和数组中的第一个元素交换位置，接着在剩下的元素中找到最小的元素，将它与第二个元素交换位置，如此循环，直到将整个数组排序完成</em></p>
<p>在选择排序中一个主要的操作是在数组中<em>找到最小的元素</em>，如何在一个给定的数组中找到值最小的那个元素呢？这个过程分为两步：</p>
<ol>
<li>遍历：</li>
</ol>
<p>遍历最简单的形式就是使用一个 for 循环，从开始索引，到结束索引，依次访问数组中的元素</p>
<ol>
<li>比较：</li>
</ol>
<p>比较至少需要两个元素，在遍历的时候，每次只访问数组中的一个元素，因此为了能够比较，需要有一个<strong>临时索引</strong>指向的元素来和当前访问的元素进行比较，如果当前元素小于临时索引指向的元素，就把当前元素的索引赋值给临时索引</p>
<p>通过以上两步，在遍历中比较，在满足<strong>当前元素小于临时索引指向的元素</strong>的条件时，就将当前元素的索引赋值给临时索引，如此循环，遍历结束后，临时索引指向的元素值就是最小元素值</p>
<p>假设有一组数</p>
<p><img src="http://7xu736.com1.z0.glb.clouddn.com/blog/images/160402/select_01.png" alt=""></p>
<p>找最小元素的过程是：</p>
<ul>
<li><p>默认临时索引为数组第一个元素，即索引为 0，开始遍历数组</p>
</li>
<li><p>当前元素是索引为 0 的元素 16，和临时索引为 0 的元素比较，相等，不赋值</p>
</li>
<li><p>当前元素是索引为 1 的元素 13，和临时索引为 0 的元素比较，小于，当前索引赋值给临时索引</p>
</li>
<li><p>当前元素是索引为 2 的元素 18，和临时索引为 1 的元素比较，大于，不赋值</p>
</li>
<li><p>当前元素是索引为 3 的元素 11，和临时索引为 1 的元素比较，小于，当前索引赋值给临时索引</p>
</li>
<li><p>当前元素是索引为 4 的元素 14，和临时索引为 3 的元素比较，大于，不赋值</p>
</li>
<li><p>当前元素是索引为 5 的元素 12，和临时索引为 3 的元素比较，大于，不赋值</p>
</li>
<li><p>遍历结束，临时索引为 3，因此索引为 3 的元素就是这个数组中的最小元素</p>
</li>
</ul>
<p>以上是<strong>一次寻找最小元素</strong>的过程，需要执行的比较次数与遍历的数组长度成正比，如果遍历的数组长为 N，则查找最小元素需要 N 次比较</p>
<p>选择排序的排序过程是：</p>
<ul>
<li>遍历索引[0-5]，找到最小元素 11，对应的索引为 3，将它与索引为 0 的元素交换，交换后如下</li>
</ul>
<ul>
<li>遍历索引[1-5]，找到最小元素 12，对应的索引为 5，将它与索引为 1 的元素交换，交换后如下</li>
</ul>
<ul>
<li>遍历索引[2-5]，找到最小元素 13，对应的索引为 5，将它与索引为 2 的元素交换，交换后如下</li>
</ul>
<ul>
<li>遍历索引[3-5]，找到最小元素 14，对应的索引为 4，将它与索引为 3 的元素交换，交换后如下</li>
</ul>
<ul>
<li>遍历索引[4-5]，找到最小元素 16，对应的索引为 4，将它与索引为 4 的元素交换，交换后如下</li>
</ul>
<ul>
<li>遍历索引[5-5]，找到最小元素 18，对应的索引为 5，将它与索引为 5 的元素交换，交换后如下</li>
</ul>
<p>从这个过程中可以分析到，在一次选择排序过程中需要<strong> N+(N-1)+(N-2)+…+3+2+1 = N(N-1)/2 ~ N^2/2 </strong>次比较和 N 次交换。并且，在选择排序中不存在最优与最坏情况，无论输入的数据情况怎样，选择排序都需要固定次数的比较和交换，因此：</p>
<p><strong>选择排序的时间复杂度为 N^2</strong></p>
<p>选择排序有两个特点：</p>
<ul>
<li><p><strong>运行时间和输入无关</strong><br>从上面的分析可以知道，选择排序中不存在最优情况和最坏情况，即使输入数据已经整体有序，选择排序所需要的比较和交换次数依然是固定的，只和输入数组的大小有关</p>
</li>
<li><p><strong>数据移动次数最少</strong><br>选择排序所需的交换次数和输入数组的大小有关，如果输入数组大小为 N，则选择排序所需交换次数为 N</p>
</li>
</ul>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> <span class="keyword">extends</span> <span class="title">SortModel</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getSortMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"选择排序"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> N = a.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">int</span> min = i;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;<span class="comment">//循环找到剩余元素中最小的,赋值给 min</span></div><div class="line">                <span class="keyword">if</span> (less(a[j], a[min])) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            exchange(a, i, min);<span class="comment">//交换 N 次</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        usedTime = endTime - startTime;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的思想如同玩纸牌时抽牌，每次抽一张，将其插入手中<strong>已经有序</strong>的牌组中，这样，每次<strong>插入前</strong>的牌组都是有序的，而要插入的这张牌就在已经有序的牌组中从高到低依次比较，在合适的位置插入。插入排序的具体实现是：在数组中遍历，索引每次加一,将新增索引对应的值插入当前索引之前的数组中(当前索引之前的数组已经有序)，在当前索引位置开始往前两两比较,如果<strong>后者小于前者就交换</strong>,如此循环,直到全部有序</p>
<p>插入排序的主要操作是插入，其过程分为两步：</p>
<ul>
<li>逆向遍历：</li>
</ul>
<p>使用 for 循环，从当前索引，到起始索引，逆向依次访问数组中的元素，直到遇到满足条件时退出循环</p>
<ul>
<li>比较：</li>
</ul>
<p>将当前索引的元素和前一位元素进行比较，如果当前索引元素小于前一位元素值，则交换(如果要求升序排序，就是小于，如果是降序排序，则是大于)</p>
<p>假设有一组数</p>
<p><img src="http://7xu736.com1.z0.glb.clouddn.com/blog/images/160402/insert_01.png" alt=""></p>
<p><strong>插入排序的排序过程是</strong>：(注意初始索引是 1 而不是 0)</p>
<ul>
<li>当前索引 1，逆向遍历[1-0]：</li>
</ul>
<ul>
<li>当前索引为 1 的元素值 13，前一位元素为 16，小于，交换<br>比较 1 次，交换 1 次，交换后的数组：</li>
</ul>
<ul>
<li><p>当前索引 2，逆向遍历[2-0]</p>
</li>
<li><p>当前索引为 2 的元素值 18，前一位元素为 16，大于，不交换</p>
</li>
<li><p>当前索引为 1 的元素值 16，前一位元素为 13，大于，不交换</p>
</li>
</ul>
<p>比较 2 次，交换 0 次，交换后的数组：</p>
<p>当前索引 3，逆向遍历[3-0]：</p>
<p>当前索引为 3 的元素值 11，前一位元素为 18，小于，交换</p>
<p>当前索引为 2 的元素值 11，前一位元素为 16，小于，交换</p>
<p>当前索引为 1 的元素值 11，前一位元素为 13，小于，交换</p>
<p>比较 3 次，交换 3 次，交换后的数组：</p>
<p>当前索引 4，逆向遍历[4-0]：</p>
<p>当前索引为 4 的元素值 14，前一位元素为 18，小于，交换</p>
<p>当前索引为 3 的元素值 14，前一位元素为 16，小于，交换</p>
<p>当前索引为 2 的元素值 14，前一位元素为 13，大于，不交换</p>
<p>当前索引为 1 的元素值 13，前一位元素为 11，大于，不交换</p>
<p>比较 4 次，交换 2 次，交换后的数组：</p>
<p>当前索引 5，逆向遍历[5-0]:</p>
<p>当前索引为 5 的元素值 12，前一位元素为 18，小于，交换</p>
<p>当前索引为 4 的元素值 12，前一位元素为 16，小于，交换</p>
<p>当前索引为 3 的元素值 12，前一位元素为 14，小于，交换</p>
<p>当前索引为 2 的元素值 12，前一位元素为 13，小于，交换</p>
<p>当前索引为 1 的元素值 12，前一位元素为 11，大于，不交换</p>
<p>比较 5 次，交换 4 次，交换后的数组：</p>
<p>注：以上执行过程中，结果为 “大于 不交换”的操作，在优化后的版本中是不会执行的，因为对 for 循环进行了控制，如果当前元素大于前一个元素，则不满足 for 循环条件，就直接返回了。</p>
<p>从上面的执行过程分析，在插入排序中，比较次数和交换次数都是和输入有关，因此会存在最优情况和最坏情况，最优情况是在输入数组已经基本有序的时候，最坏情况是在输入数组为逆序的时候，下面分别从最优情况，最坏情况和平均情况分析插入排序的性能</p>
<p>最优情况：<br>当输入数据已经基本有序时，比如输入数据为 11,12,13,14,16,18 ，则需要的比较次数为 1+1+1+1+1=5 次，交换次数为 0 次，延伸到长度为 N 的输入数据中，比较次数为 N，交换次数为 0。</p>
<p>最坏情况：<br>当输入数据为逆序是，比如输入数据为 18,16,14,13,12,11 ，则需要的比较次数为 1+2+3+4+5=15 次，交换次数为 1+2+3+4+5=15 次，延伸到长度为 N 的输入数据中，比较次数为 1+2+3+…+(N-2)+(N-1)+N = N(N-1)/2 ~ N^2/2，交换次数为 1+2+3+…+(N-2)+(N-1)+N = N(N-1)/2 ~ N^2/2</p>
<p>平均情况：<br>已经知道了最优情况和最坏情况下的比较次数和交换次数，平均情况就是 (最优情况 + 最坏情况) / 2，因此，平均情况下，插入排序需要的比较次数为 ~ N^2/4，交换次数为 ~ N^2/4</p>
<p>通过以上对插入排序的分析，可以总结几点：</p>
<p>插入排序对部分有序的数组十分高效，也很适合小规模数组</p>
<p>可以对插入排序进行优化，比如在内循环中将较大的元素向右移动而不总是交换两个相邻的元素</p>
<p>代码实现：</p>
<p>public class InsertionSort extends SortModel {<br>    @Override<br>    protected String getSortMethod() {<br>        return “插入排序”;<br>    }<br>    @Override<br>    protected void sort(int[] a) {<br>        long startTime = System.currentTimeMillis();<br>        int N = a.length;<br>        for (int i = 1; i &lt; N; i++) {<br>            //从当前索引位置往前遍历，如果找到满足”后者小于前者”条件的,就交换两者的位置<br>            //这里有个改进的写法，之前的写法是这样的：<br>            //  for (int j = i; j &gt; 0; j–) {<br>            //        if(less(a[j], a[j - 1])){<br>            //            exchange(a, j, j - 1);<br>            //        }<br>            //  }<br>            //这种写法会导致每次的 for 循环都会一直进行到底，就会导致插入排序的比较次数是固定的<br>            //而下面这种写法，在不满足条件的情况下，就会结束 for 循环，因此比较次数是跟输入有关的<br>            //因而是可以存在最优情况的<br>            for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j–) {<br>                    exchange(a, j, j - 1);<br>            }<br>        }<br>        long endTime = System.currentTimeMillis();<br>        usedTime = endTime - startTime;<br>    }<br>}<br>希尔排序</p>
<p>希尔排序基于插入排序，改进了插入排序对于大规模乱序数组排序很慢的缺点，比如，如果一个值最小的元素正好在数组的尽头，要将它移到正确的位置(数组起始位置)，如果使用插入排序，需要移动 N－1 次，希尔排序改进的方法就是交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。希尔排序使数组中任意间隔为 h 的元素都是有序的，然后再逐渐缩小 h 的值，直到 h=1，整个数进行插入排序，最终使数组有序。书中给出的增量 h 的计算公式为 h=1/2(3^k-1),其中 k = 1,2,3,4,5…，这样得到的 h 值是 1，4，13，40，121，364…的序列，在 h 小于数组的三分之一时(即 h &lt; N/3)h 值开始递减至 1。</p>
<p>假设有一组数：</p>
<p>希尔排序的排序过程是：</p>
<p>根据公式计算得到递增序列的最大值，计算得到 h = 4</p>
<p>h 值为 4，即递减量为 4，遍历 [4,5]</p>
<p>当前索引为 4，逆向遍历[4,4]，递减序列为 (4,0)</p>
<p>当前索引为 4 的元素值为 14，前一位元素是索引为 0 的元素 16，小于，交换<br>比较 1 次，交换 1 次，交换后的数组：</p>
<p>当前索引为 5，逆向遍历[5,4]，递减序列为 (5,1)</p>
<p>当前索引为 5 的元素值为 12，前一位元素是索引为 1 的元素 13，小于，交换<br>比较 1 次，交换 1 次，交换后的数组：</p>
<p>h 值为 1，即递减量为 1，遍历 [1,5]</p>
<p>当前索引为 1，逆向遍历[1,1]，递减序列为 (1,0)</p>
<p>当前索引为 1 的元素值为 12，前一位元素是索引为 0 的元素 14，小于，交换<br>比较 1 次，交换 1 次，交换后的数组：</p>
<p>当前索引为 2，逆向遍历[2,1]，递减序列为 (2,1,0)</p>
<p>当前索引为 2 的元素值为 18，前一位元素是索引为 1 的元素 14，大于，不交换<br>比较 1 次，交换 0 次，交换后的数组：</p>
<p>当前索引为 3，逆向遍历[3,1]，递减序列为 (3,2,1,0)</p>
<p>当前索引为 3 的元素值为 11，前一位元素是索引为 2 的元素 18，小于，交换</p>
<p>当前索引为 2 的元素值为 11，前一位元素是索引为 1 的元素 14，小于，交换</p>
<p>当前索引为 1 的元素值为 11，前一位元素是索引为 0 的元素 12，小于，交换</p>
<p>比较 3 次，交换 3 次，交换后的数组：</p>
<p>当前索引为 4，逆向遍历[4,1]，递减序列为 (4,3,2,1,0)</p>
<p>当前索引为 4 的元素值为 16，前一位元素是索引为 3 的元素 18，小于，交换</p>
<p>当前索引为 3 的元素值为 16，前一位元素是索引为 2 的元素 14，大于，不交换</p>
<p>比较 2 次，交换 1 次，交换后的数组：</p>
<p>当前索引为 5，逆向遍历[5,1]，递减序列为 (5,4,3,2,1,0)</p>
<p>当前索引为 5 的元素值为 13，前一位元素是索引为 4 的元素 18，小于，交换</p>
<p>当前索引为 4 的元素值为 13，前一位元素是索引为 3 的元素 16，小于，交换</p>
<p>当前索引为 3 的元素值为 13，前一位元素是索引为 2 的元素 14，小于，交换</p>
<p>当前索引为 2 的元素值为 13，前一位元素是索引为 1 的元素 12，大于，不交换</p>
<p>比较 4 次，交换 3 次，交换后的数组：</p>
<p>从上面的分析可以看到，希尔排序是在插入排序的基础上进行了一些优化，希尔排序的性能也是受输入影响的，因此也存在最优情况和最坏情况，最优情况下的时间复杂度为O(N)。最坏情况下的时间复杂度根据步长(增量)的选择而不同</p>
<p>步长序列    最优情况    最坏情况<br>n/(2^i)    N    N^2<br>2^k-1    N    N^(3/2)<br>(2^i)*(3^j)    N    Nlog(2)N<br>代码实现：</p>
<p>public class ShellSort extends SortModel {<br>    @Override<br>    protected String getSortMethod() {<br>        return “希尔排序”;<br>    }<br>    @Override<br>    protected void sort(int[] a) {<br>        long startTime = System.currentTimeMillis();<br>        int N = a.length;<br>        int h = 1;<br>        while (h &lt; N / 3) {//根据 N 计算递增序列中的最大值,1,4,13,40,121…<br>            h = 3 * h + 1;<br>        }<br>        while (h &gt;= 1) {//逐渐缩小递增序列进行排序,13,4,1<br>            for (int i = h; i &lt; N; i++) {//在最后一个增量段中遍历 i<br>                //从 i 还是逐增量,得到的一个相隔增量段的序列进行插入排序<br>                for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) {<br>                        exchange(a, j, j - h);<br>                }<br>            }<br>            h = h / 3;//增量递减<br>        }<br>        long endTime = System.currentTimeMillis();<br>        usedTime = endTime - startTime;<br>    }<br>}<br>归并排序</p>
<p>归并排序的思想是：要将一个数组排序，可以先将它分成两个子数组分别排序，然后将结果归并起来。在归并排序中，排序的过程是,把一个数据分成两个子数组,每个子数组进行排序(递归的尽头,一个子数组中只有两个元素,这时的排序只需要简单的比较两个元素的大小)，然后再把有序的子数组归并成一个整体有序的数组，总结起来就是,先分解成最小单元,再组合成一个整体。</p>
<p>假设有一组数：</p>
<p>归并排序主要分为两个步骤：</p>
<p>二分</p>
<p>二分的过程主要是将一个数组分成两个子数组，直到最后数组中只剩下一个元素</p>
<p>归合</p>
<p>归并的过程是将两个已经有序的子数组，整合成一个有序的数组。直到全部数组都整合完成，整个数组就实现了有序</p>
<p>归并排序的排序过程是：(其中 lo 为数组最低位索引，mid 为数组中间位置索引，hi 为数组最高位索引)</p>
<p>对数组排序：[0,5], lo=0, mid=2, hi=5</p>
<p>对左半部分排序：[0,2], lo=0, mid=1, hi=2</p>
<p>对左半部分排序：[0,1], lo=0, mid=0, hi=1</p>
<p>对左半部分排序：[0,0],lo=0, mid=0, hi=0</p>
<p>对右半部分排序：[1,1],lo=1, mid=1, hi=1</p>
<p>对数组归并： lo=0, mid=0, hi=1</p>
<p>对右半部分排序：[2,2],lo=2,mid=2,hi=2</p>
<p>对数组归并： lo=0, mid=1, hi=2</p>
<p>对右半部分排序：[3,5], lo=3, mid=4, hi=5</p>
<p>对左半部分排序：[3,4], lo=3, mid=3, hi=4</p>
<p>对左半部分排序：[3,3],lo=3, mid=3, hi=3</p>
<p>对右半部分排序：[4,4],lo=4, mid=4, hi=4</p>
<p>对数组归并：lo=3, mid=3, hi=4</p>
<p>对右半部分排序：[5,5],lo=5, mid=5, hi=5</p>
<p>对数组归并：lo=3, mid=4, hi=5</p>
<p>对数组归并：lo=0, mid=2, hi=5</p>
<p>归并排序在进行二分的时候，将长度为 N 的数组分为两个长度为 N/2 的数组，依此递推，直到最后分为长度为 1 的数组，很容易想到这个过程中的需要的操作次数为 N(1 + 1/2 + 1/4 + … + 1/N) + N ~ NlgN,在 归并的过程中，需要一个额外的数组作为临时存储，因此归并排序还需要一个额外的内存开销，其空间复杂度为 N</p>
<p>关于归并排序时间复杂度的计算，可以参考 这篇文章</p>
<p>代码实现：</p>
<p>public class MergeSort extends SortModel {<br>    int[] temp;<br>    @Override<br>    protected String getSortMethod() {<br>        return “归并排序”;<br>    }<br>    @Override<br>    protected void sort(int[] a) {<br>        long startTime = System.currentTimeMillis();<br>        temp = new int[a.length];<br>        sortT2B(a, 0, a.length - 1);<br>        long endTime = System.currentTimeMillis();<br>        usedTime = endTime - startTime;<br>    }<br>    private void sortT2B(int[] a, int lo, int hi) {<br>        if (hi &gt; lo) {<br>            int mid = lo + (hi - lo) / 2;//取数组中间位置索引<br>            sortT2B(a, lo, mid);//递归排序左边的元素<br>            sortT2B(a, mid + 1, hi);//递归排序右边的元素<br>            merge(a, lo, mid, hi);//归并<br>        }<br>    }<br>    /**</p>
<pre><code> * 归并操作,将两个有序的数组归并成一个有序的数组
 * &lt;p&gt;
 * 首先将数组复制到临时数组 temp 中
 * 将临时数组分为左右两部分,左边部分索引起始位置为 i,右边部分索引起始位置为 j
 * 将左右两部分归并到原来的数组中
 *
 * @param a   数组
 * @param lo  数组第一个元素
 * @param mid 数组中间的元素
 * @param hi  数组最后一个元素
 */
private void merge(int[] a, int lo, int mid, int hi) {
    int i = lo, j = mid + 1;
    for (int k = lo; k &lt;= hi; k++) {//复制数组
        temp[k] = a[k];
    }
    for (int k = lo; k &lt;= hi; k++) {
        if (i &gt; mid) {//如果左边用尽,则取右边的元素
            a[k] = temp[j++];
        } else if (j &gt; hi) {//如果右边用尽,则取左边的元素
            a[k] = temp[i++];
        } else if (less(temp[j], temp[i])) {//如果右边当前元素小于左边当前元素,则取右边元素
            a[k] = temp[j++];
        } else {//右边当前元素大于左边当前元素,则取左边元素
            a[k] = temp[i++];
        }
    }
}
</code></pre><p>}<br>快速排序</p>
<p>快速排序是应用最广泛的排序算法，基本思路是：将一个数组分成两个子数组,将两部分独立排序,当两个子数组都有序时,整个数组也就有序了，这与归并排序有所不同，归并排序中，将一个数组分成两个数组后，需要对两个子数组进行归并，在归并的过程中排序，而快速排序是在将一个数组分成两个数组的过程中进行排序，当分到尽头的时候，数组就已经有序了，不需要再进行其它任何操作</p>
<p>快速排序中重点是找到将一个数组分为两个数组的切分点，在归并排序中，其实也是有这样的切分点的，就是 mid，也就是说归并排序默认将一个数组等分，而在快速排序中，对一个数组的切分，并不一定是等分，需要根据具体的切分点的位置来进行切分，所以，找到合适的切分点的位置是很重要的，直接影响到整个排序的性能。</p>
<p>寻找切分点</p>
<p>切分点需要满足三个条件：(假设切分点索引为 k)</p>
<p>对于某个索引 k,数组中对应索引的值 a[k] 是确定的<br>数组索引[lo,k-1] (即切分点左边的所有元素) 中的所有元素的值都不大于切分点元素的值( &lt;= )<br>数组索引[k+1,hi] (即切分点右边的所有元素) 中的所有元素的值都不小于切分点元素的值( &gt;= )<br>假设有一组数：</p>
<p>寻找切分点的过程是：(其中 lo 为数组最低位索引，hi 为数组最高位索引，从左往右遍历的指针为 i，从右往左遍历的指针为 j)</p>
<p>取 a[lo] 的值作为初始切分点元素的值，即切分点索引为 0，值为 16</p>
<p>从数组左端向右遍历[1,5]，当遇到一个大于等于切分点的元素，即索引为 2 的元素，停止遍历，此时 i=2</p>
<p>从数组右端向左遍历[5,0]，当遇到一个小于等于切分点的元素，即索引为 5 的元素，停止遍历，此时 j=5</p>
<p>交换 i 和 j 对应的值，交换后:</p>
<p>从数组左端向右遍历[3,5]，当遇到一个大于等于切分点的元素，即索引为 5 的元素，停止遍历，此时 i=5</p>
<p>从数组右端向左遍历[4,0]，当遇到一个小于等于切分点的元素，即索引为 4 的元素，停止遍历，此时 j=4</p>
<p>当 i&gt;=j 时停止循环，不会执行 i 和 j 的交换，而是将切分点元素和 j 元素交换，交换后:</p>
<p>到此，寻找第一个切分点完成，切分点索引为 4，对应的值为 16</p>
<p>找到切分点，接下来将数组按照切分点分成两部分，从上面的执行结果可以知道，数组将被分为 [0,3] 和 [5,5]，接下来就是对 [0,3] 部分重复寻找切分点的过程：</p>
<p>取 a[lo] 的值作为初始切分点元素的值，即切分点索引为 0，值为 14</p>
<p>从数组左端向右遍历[1,3]，当遇到一个大于等于切分点的元素，没有找到，遍历到数组尽头，此时 i=3</p>
<p>从数组右端向左遍历[3,0]，当遇到一个小于等于切分点的元素，即索引为 3 的元素，停止遍历，此时 j=3</p>
<p>当 i&gt;=j 时停止循环，不会执行 i 和 j 的交换，而是将切分点元素和 j 元素交换，交换后:</p>
<p>到此，寻找第二个切分点完成，切分点索引为 3，对应的值为 14</p>
<p>同理，数组将按照切分点分为 [0,2] 和[3,3]，接下来对 [0,2] 部分重复寻找切分点：</p>
<p>取 a[lo] 的值作为初始切分点元素的值，即切分点索引为 0，值为 11</p>
<p>从数组左端向右遍历[1,2]，当遇到一个大于等于切分点的元素，即索引为 1 的元素，停止遍历，此时 i=1</p>
<p>从数组右端向左遍历[2,0]，当遇到一个小于等于切分点的元素，没有找到，遍历到数组起始位置，此时 j=0</p>
<p>当 i&gt;=j 时停止循环，不会执行 i 和 j 的交换，而是将切分点元素和 j 元素交换，交换后:</p>
<p>到此，寻找第三个切分点完成，切分点索引为 0，对应的值为 11</p>
<p>此时，由于切分点位置为 0，所以只能切分出一个子数组，即 [1,2]，继续寻找切分点</p>
<p>取 a[lo] 的值作为初始切分点元素的值，即切分点索引为 1，值为 13</p>
<p>从数组左端向右遍历[2,2]，当遇到一个大于等于切分点的元素，没有找到，遍历到数组尽头，此时 i=2</p>
<p>从数组右端向左遍历[2,1]，当遇到一个小于等于切分点的元素，即索引为 2 的元素，此时 j=2</p>
<p>当 i&gt;=j 时停止循环，不会执行 i 和 j 的交换，而是将切分点元素和 j 元素交换，交换后:</p>
<p>到此，寻找第四个切分点完成，切分点索引为 2，对应的值为 12</p>
<p>数据已经有序了，整个过程中寻找了四次切分点</p>
<p>排序过程</p>
<p>下面整理完整的排序过程，将会忽略寻找切分点的过程，直接给出找到的切分点</p>
<p>假设有一组数：</p>
<p>快速排序的过程是：</p>
<p>寻找切分点，索引为 4，值为16</p>
<p>对左半部分排序：[0,3]</p>
<p>寻找切分点，索引为 3，值为 14，进行了 1 次交换，交换后的数组是</p>
<p>对左半部分排序：[0,2]</p>
<p>寻找切分点，索引为 0，值为 11，进行了 1 次交换，交换后的数组是</p>
<p>对左半部分排序：[0,-1]</p>
<p>对右半部分排序：[1,2]</p>
<p>寻找切分点，索引为 2，值为 12，进行了 1 次交换，交换后的数组是</p>
<p>对左半部分排序：[1,1]</p>
<p>对右半部分排序：[3,2]</p>
<p>对右半部分排序：[4,3]</p>
<p>对右半部分排序：[5,5]</p>
<p>快速排序是一个递归切分排序的过程，其切分点的定位依赖于输入数据，因此快速排序存在最优情况和最坏情况，最优情况是在每一次切分点都正好处于数组中间位置时，最坏情况则是在每一次切分后两个子数组其中之一为空时，下面来分析下快速排序的性能特点</p>
<p>最优情况：</p>
<p>在最优情况下，每次的切分点都是正好处在数组中间位置，这样得到的每次切分都是均匀的二分，可以考虑二叉树的结构，假设有如下数组：</p>
<p>如果每次切分点都在正中间，则可以将上面的数组看成是一个平衡二叉树，如下所示：</p>
<p>对于长度为 N 的数组，在最优情况下，二叉树的深度是 log2N+1,需要 log2N 次递归，在每次寻找切分点时，都要对当前数组进行逐个元素比较，比如，在第一次寻找切分点时，需要分别从左右两端向中间逐个比较，需要的比较次数为 N，在第二次寻找切分点时，需要先对左子数组递归比较，在对右子数组递归比较，实际需要 2*N/2 = N 次比较。也就是说，在二叉树的每一层，都需要 N 次比较，因此对于 log2N 层，时间复杂度为 Nlog2N</p>
<p>最好情况下，快速排序的时间复杂度是 NlogN 级别</p>
<p>平均情况：</p>
<p>对于长度为 N 的数组，令 C(N) 为将 N 个不同元素排序平均需要的比较次数，当 N &lt;= 1 时，存在 C(0)=C(1)=0，当 N &gt;1 时，对数组进行快速排序，需要进行三个步骤：</p>
<p>切分：每次切分，对长度为 N 的数组，需要进行 N+1 次比较</p>
<p>将左子数组排序的平均成本：对于长度为 N 的数组，需要 (C(0)+C(1)+…+C(N-2)+C(N-1))/N 次操作</p>
<p>将右子数组排序的平均成本：对于长度为 N 的数组，需要 (C(N-1)+C(N-2)+…+C(1)+C(0))/N 次操作</p>
<p>整理得到如下公式：</p>
<p>C(N)= (N+1) + (C(0)+C(1)+…+C(N-2)+C(N-1))/N + (C(N-1)+C(N-2)+…C(1)+C(0))/N</p>
<p>通过对公式的变换，可以的到这样的结果：</p>
<p>C(N) ~ 2(N+1)lnN ~ 1.39NlogN</p>
<p>平均情况下，快速排序的时间复杂度是 NlogN 级别</p>
<p>最坏情况：</p>
<p>在每次切分后两个子数组之一为空的时候，便是快速排序的最坏情况，这样会导致一个大子数组需要切分很多次，对于长度为 N 的数组，在这种情况下，比较次数是：N+(N-1)+(N-2)+…+2+1 = (N+1)N/2 ~ N^2/2</p>
<p>在最坏情况下，快速排序的时间复杂度是 N^2 级别</p>
<p>关于快速排序时间复杂度的具体推导过程可以参考 这片文章</p>
<p>代码实现：</p>
<p>public class QuickSort extends SortModel {<br>    @Override<br>    protected String getSortMethod() {<br>        return “快速排序”;<br>    }<br>    @Override<br>    protected void sort(int[] a) {<br>        long startTime = System.currentTimeMillis();<br>        sort(a, 0, a.length - 1);<br>        long endTime = System.currentTimeMillis();<br>        usedTime = endTime - startTime;<br>    }<br>    private void sort(int[] a, int lo, int hi) {<br>        if (hi &gt; lo) {<br>            int j = partition(a, lo, hi);//找到切分点<br>            sort(a, lo, j - 1);//对左半部分排序<br>            sort(a, j + 1, hi);//对右半部分排序<br>        }<br>    }<br>    /**</p>
<pre><code> * 找到切分点,使得切分点左边所有元素都不大于切分点,右边有所有素都不小于切分点
 *
 * @param a  数组
 * @param lo 数组起始位置
 * @param hi 数组结束为止
 * @return 切分点
 */
private int partition(int[] a, int lo, int hi) {
    //这里 j 取 hi+1,是因为在循环中用的 --j,是先执行减操作再比较,因此在首次执行时如果直接取 j 为 hi,会忽略hi 这个元素,直接比较 hi-1
    //而 i 取 lo,没有取 lo-1 是因为默认取第一个元素为切分点,正好需要略过第一个元素,所以这样第一个比较的元素其实是 lo+1
    int i = lo, j = hi + 1;
    int v = a[lo];
    while (true) {
        while (less(a[++i], v)) {//从起始位置向右扫描,直到找到一个大于等于切分点的元素
            if (i == hi) {
                break;
            }
        }
        while (less(v, a[--j])) {//从右端向左扫描,直到找到一个小于等于切分点的元素
            if (j == lo) {
                break;
            }
        }
        if (i &gt;= j) {//当两个指针相遇,则中断循环
            break;
        }
        exchange(a, i, j);//交换两个元素
    }
    exchange(a, lo, j);//交换切分点和左子数组最右端的元素交换,这样返回的就是最新的切分点元素值了
    return j;
}
</code></pre><p>}<br>堆排序</p>
<p>在了解堆排序之前，需要先了解二叉堆这种数据结构，它的定义是：二叉堆是一组能够用堆有序(每个节点都大于等于它的两个字节点时，堆有序)的完全二叉树排序的元素，并在数组中按照层级储存(不使用数组的第一个位置，就是不使用索引 0 ，索引从 1 开始)</p>
<p>在二叉堆中存在这样一种关系：索引位置为 k 的元素，他的父节点索引位置为 k/2，而它的两个字节点索引位置分别为 2k 和 2k+1。这样就能很容易在二叉堆中上下移动，比如，从 a[k] 位置向上层移动就令 k=k/2，向下层移动就令 k=2k 或者 k=2k+1</p>
<p>在堆中有两个比较重要的操作，也是用来排序的操作，即由下至上的堆有序化(上浮)和由上至下的堆有序化(下沉)</p>
<p>上浮：如果某个节点的值比它的父节点还大，就需要通过上浮操作，使它和它的父节点交换，以此来达到从上至下的有序状态<br>下沉：如果某个节点的值比它的两个子节点中较大者还小，就需要通过下沉操作，使它和它的子节点中较大者交换，以此来达到从上至下的有序状态<br>堆排序正是利用了二叉堆的这个性质来完成排序的。堆排序的过程大致分为两步：初始构造堆，然后是下沉排序。</p>
<p>初始构造堆就是把要排序的数组构造成一个二叉堆，初始构造的堆只需要满足：当前节点大于它的两个字节点并且小于它的父节点即可，并不需要在初始构造阶段进行排序</p>
<p>下沉排序是从数组末尾开始逆序遍历将所有的数都放在数组起始位置(索引为 1)，然后让他根据下沉规则找到合适的位置，这样，当遍历到数组起始位置时，数组就有序了</p>
<p>假设有一组数：16，13，18，11，14，12</p>
<p>堆排序分为两个过程：构造堆和下沉排序，其中构造堆就是将一个数组构造成具有堆的性质(当前节点大于其左右子节点的值)，构造完成的堆满足从上至下的有序状态，即当前节点大于其子节点，但是在其两个子节点中并不存在有序状态，于是需要使用下沉操作将堆从下至上进行排序，使堆整体有序。</p>
<p>构造堆：</p>
<p>根据二叉堆的性质，可以知道，在要排序的数组中存在如下关系：</p>
<p>将其转换成二叉树的结构，如下图：</p>
<p>接下来就是根据堆的性质，对堆中元素进行下沉操作，将其构造成一个堆。假设数组长度为 N,数组的中点位置索引为 K，则存在 K=N/2，对于节点 K，它的两个子节点分别在索引为 K/2 的位置和索引为 K/2+1 的位置，则对 K 位置的元素进行下沉操作的步骤是：</p>
<p>找到 K 的两个子节点 K<em>2 和 K</em>2+1</p>
<p>比较两个子节点，找到其中较大的节点,设为 J</p>
<p>如果 K 节点元素小于 J 节点元素，则交换两个元素，否则什么也不做</p>
<p>通过从数组中点位置开始向起点循环对元素执行上诉三个步骤，便能将数组变成一个堆有序的二叉堆。</p>
<p>由于画图不方便，因此在堆排序这里就没有用图片来解释每一步的情况，用文字来描述</p>
<p>构造二叉堆之后的数组是这样的：</p>
<p>从后向前的下沉排序</p>
<p>在排序的时候，会按照如下步骤执行</p>
<p>取数组最后一个元素，将它与数组第一个元素交换</p>
<p>对数组第一个元素进行下沉操作，使其寻找到合适的位置</p>
<p>取数组倒数第二个元素，步骤同上</p>
<p>按照上面的步骤，从数组最后一个元素，一直到第一个元素，执行下沉操作，最终就能使数组有序。</p>
<p>性能</p>
<p>堆排序不依赖于输入数据，因此不存在最好情况和最坏情况，下面从堆的构造和下沉排序两方面分析堆排序的性能</p>
<p>构造堆时：</p>
<p>假如数组长度为 N，即堆有 N 个节点，那么堆的高度为 H=logN，最后一层每个父节点最多只需要下沉 1 次，倒数第二层最多只需要下沉 2 次，顶点最多需要下沉 H 次，而最后一层父节点共有 2^(H-1) 个,倒数第二层共有 2^(H-2) 个,顶点只有 1(2^0) 个，所以总共的时间复杂度为</p>
<p>S = 1 <em> 2^(H-1) + 2 </em> 2^(H-2) + … + (H-1) <em> 2^1 + H </em> 2^0</p>
<p>将 H 代入后 S = 2N - 2 - log2(N) ~ O(N)。</p>
<p>因此，在构造堆时，时间复杂度为 O(N)</p>
<p>下沉排序:</p>
<p>在长度为 N 的数组中，构造成的堆，高度为 H=logN,下沉排序过程中，每次将数组最后的数与第一个数交换，然后对第一个数进行下沉操作，因为堆的高度为 logN，因此每次下沉操作的时间复杂度为 logN，而数组中有 N 个数，因此，总的时间复杂度为 NlogN</p>
<p>综上，将构造堆的时间复杂度与下沉排序的时间复杂度相加就能得到最终的结果</p>
<p>堆排序的时间复杂度为 N + NlogN ~ NlogN</p>
<p>代码实现：</p>
<p>public class HeapSort extends SortModel {<br>    @Override<br>    protected String getSortMethod() {<br>        return “堆排序”;<br>    }<br>    @Override<br>    protected void sort(int[] a) {<br>        long startTime = System.currentTimeMillis();<br>        int N = a.length;<br>        for (int k = N / 2; k &gt;= 1; k–) {//将数组构成造堆<br>            sink(a, k, N);<br>        }<br>        while (N &gt; 1) {<br>            exchange(a, 1, N–);<br>            sink(a, 1, N);<br>        }<br>        long endTime = System.currentTimeMillis();<br>        usedTime = endTime - startTime;<br>    }<br>    private void sink(int[] a, int k, int N) {<br>        while (2 <em> k &lt;= N) {<br>            int j = 2 </em> k;<br>            if (j &lt; N &amp;&amp; less(a,j, j + 1)) {//取 k 的子节点中较大的那一个<br>                j++;<br>            }<br>            if (!less(a,k, j)) {//如果 k 元素已经大于 j 元素了则直接跳出循环<br>                break;<br>            }<br>            exchange(a, k, j);//k 元素小于 j 元素,则交换两者<br>            k = j;<br>        }<br>    }<br>    private  boolean less(int[] pq, int i, int j) {<br>        return pq[i - 1] &lt; pq[j - 1];<br>    }<br>    @Override<br>    protected void exchange(int[] arr, int a, int b) {<br>        int swap = arr[a - 1];<br>        arr[a - 1] = arr[b - 1];<br>        arr[b - 1] = swap;<br>    }<br>}</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://wanghanfeng.com/2017/02/24/基础排序算法/" data-id="cj1918s8w001duau2vip9xj9d" class="article-share-link">分享到</a><div class="tags"><a href="/tags/排序/">排序</a></div><div class="post-nav"><a href="/2017/02/26/HTTP与HTTPS/" class="pre">HTTP与HTTPS</a><a href="/2017/02/18/CSS中绝对定位于相对定位/" class="next">CSS中绝对定位与相对定位</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://wanghanfeng.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac操作/">Mac操作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-iTunes/">iOS iTunes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-开发/">iOS 开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器搭建/">服务器搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法与数据结构/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/AFNetworking-Objective-C/" style="font-size: 15px;">AFNetworking  Objective-C</a> <a href="/tags/location/" style="font-size: 15px;">location</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/数据持久化/" style="font-size: 15px;">数据持久化</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/框架/" style="font-size: 15px;">框架</a> <a href="/tags/Block/" style="font-size: 15px;">Block</a> <a href="/tags/component/" style="font-size: 15px;">component</a> <a href="/tags/runtime/" style="font-size: 15px;">runtime</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/算法与数据结构/" style="font-size: 15px;">算法与数据结构</a> <a href="/tags/苹果开发者/" style="font-size: 15px;">苹果开发者</a> <a href="/tags/垃圾回收/" style="font-size: 15px;">垃圾回收</a> <a href="/tags/网络优化/" style="font-size: 15px;">网络优化</a> <a href="/tags/iOS-开发/" style="font-size: 15px;">iOS 开发</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">王韩峰的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>